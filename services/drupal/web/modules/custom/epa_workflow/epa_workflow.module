<?php

/**
 * @file
 * Contains epa_workflow.module.
 */

use Drupal\content_moderation\Entity\ContentModerationStateInterface;
use Drupal\content_moderation_notifications\ContentModerationNotificationInterface;
use Drupal\Core\Entity\EntityInterface;
use Drupal\Core\Entity\EntityTypeInterface;
use Drupal\Core\Field\BaseFieldDefinition;
use Drupal\Core\Form\FormStateInterface;
use Drupal\Core\Link;
use Drupal\Core\Url;

/**
 * Implements hook_entity_base_field_info().
 */
function epa_workflow_entity_base_field_info(EntityTypeInterface $entity_type) {
  $fields = [];
  $config_syncing = \Drupal::isConfigSyncing();
  if ($entity_type->id() == 'node' && !$config_syncing) {
    $fields['epa_revision_automated'] = BaseFieldDefinition::create('boolean')
      ->setLabel(t('Moderation automated'))
      ->setDescription(t('When true current moderation state is automated.'))
      ->setRevisionable(TRUE)
      ->setDefaultValue(NULL);
  }
  return $fields;
}

/**
 * Implements hook_ENTITY_TYPE_insert().
 */
function epa_workflow_content_moderation_state_insert(ContentModerationStateInterface $entity) {
  $epa_moderation = \Drupal::service('epa_workflow.moderation_manager');
  if ($epa_moderation->isModeratedEntity($entity)) {
    $epa_moderation->processModeration($entity);
  }
}

/**
 * Implements hook_ENTITY_TYPE_update().
 *
 * @see Drupal\group\Entity\GroupContent::postSave
 * @see https://www.drupal.org/project/group/issues/2872697
 * @see https://www.drupal.org/project/drupal/issues/2803717
 */
function epa_workflow_content_moderation_state_update(ContentModerationStateInterface $entity) {
  $epa_moderation = \Drupal::service('epa_workflow.moderation_manager');
  // Group will trigger an update after insert.
  // Check to see if entity is moderated.
  // Check to see if content revision id has changed.
  // Also, check that the moderation state isn't looping over itself.
  if ($epa_moderation->isModeratedEntity($entity)
      && $entity->content_entity_revision_id->value != $entity->original->content_entity_revision_id->value
      && $entity->getRevisionId() != $entity->getLoadedRevisionId()
  ) {
    $epa_moderation->processModeration($entity);
  }
}

/**
 * Implements hook_form_FORM_ID_alter().
 *
 * @todo This should probably be contributed back.
 */
function epa_workflow_form_content_moderation_notification_form_alter(array &$form, FormStateInterface $form_state) {
  $workflow_id = $form['workflow']['#default_value'];
  $workflow = \Drupal::entityTypeManager()->getStorage('workflow')->load($workflow_id);
  $entity_types = $workflow->getTypePlugin()->getEntityTypes();
  $entity_types[] = 'content_moderation_notifications';
  $form['body']['token_tree_link']['#token_types'] = array_unique(array_merge($form['body']['token_tree_link']['#token_types'], $entity_types));

  $notification = $form_state->getFormObject()->getEntity();
  $workflow_process = $notification->getThirdPartySetting('epa_workflow', 'workflow_process', 'any');
  $workflow_options = [
    'any' => t('Any'),
    'automatic' => t('Automatic'),
    'manual' => t('Manual'),
  ];

  $form['workflow_process'] = [
    '#type' => 'radios',
    '#title' => t('Workflow Process'),
    '#options' => $workflow_options,
    '#description' => t('Notification will react to the selected trigger.'),
    '#default_value' => $workflow_process,
  ];

  $form['#entity_builders']['epa_workflow'] = '_epa_workflow_moderation_form_entity_builder';
}

/**
 * Entity builder for content_moderation_notification_form.
 */
function _epa_workflow_moderation_form_entity_builder($entity_type_id, ContentModerationNotificationInterface $notification, &$form, FormStateInterface &$form_state) {
  $workflow_process = $form_state->getValue('workflow_process', 'any');
  $notification->setThirdPartySetting('epa_workflow', 'workflow_process', $workflow_process);
}

/**
 * Implements hook_mail_alter().
 *
 * Sets header content type to html.
 * Can also achieve by installing mailsystem and add a module specific
 * configuration for content_moderation_notifications.
 *
 * @see https://www.drupal.org/project/content_moderation_notifications/issues/2903550
 */
function epa_workflow_mail_alter(&$message) {
  if ($message['id'] == 'content_moderation_notifications_content_moderation_notification') {
    $message['headers']['Content-Type'] = 'text/html; charset=UTF-8; format=flowed; delsp=yes';

    // Log here to avoid having to create our own mail service
    $logger = \Drupal::logger('epa_workflow');
    $transition = \Drupal::service('content_moderation_notifications.notification_information')->getTransition($message['params']['context']['node']);
    $logger->info('Notification email with subject: %subject was sent to: %to  when the %transition transition was executed on revision %vid', ['%to' => $message['params']['headers']['Bcc'], '%subject' => $message['subject'], '%vid' => $message['params']['context']['node']->getRevisionId(), '%transition' => $transition->label()]);
  }
}

/**
 * Implements hook_content_moderation_notification_mail_data_alter().
 */
function epa_workflow_content_moderation_notification_mail_data_alter(EntityInterface $entity, array &$data) {
  $eic_notifications = [
    'epa_content_has_been_approved',
    'epa_content_needs_review',
    'epa_content_needs_review_manual',
    'epa_content_about_to_expire',
    'epa_content_has_expired',
    'epa_content_will_expire',
  ];
  if (in_array($data['notification']->id, $eic_notifications)) {
    $groups = \Drupal::service('epa_web_areas.web_areas_helper')->getNodeReferencingGroups($entity);
    foreach ($groups as $group) {
      $eic_email = $group->field_editor_in_chief->entity->mail->value;
      if (!in_array($eic_email, $data['to'])) {
        $data['to'][] = $eic_email;
      }

      // Add editors for all notifications except Published needs review.
      if ($data['notification']->id != 'epa_content_needs_review') {
        $members = $group->getMembers('editor');
        foreach ($members as $member) {
          $editor_email = $member->getUser()->getEmail();
          if (!in_array($editor_email, $data['to'])) {
            $data['to'][] = $editor_email;
          }
        }
      }
    }
  }
}

/**
 * Implements hook_field_formatter_info_alter().
 */
function epa_workflow_field_formatter_info_alter(array &$info) {
  if (!empty($info['scheduled_publish_generic_formatter'])) {
    $info['scheduled_publish_generic_formatter']['class'] = 'Drupal\epa_workflow\Plugin\Field\FieldFormatter\EPAScheduledPublishGenericFormatter';
  }
}

/**
 * Implements hook_ENTITY_TYPE_revision_create().
 */
function epa_workflow_node_revision_create(EntityInterface $new_revision, EntityInterface $entity, $keep_untranslatable_fields) {
  // remove any schedule field settings from the previous revision
  $new_revision->set('field_scheduled_transition', NULL);
}

function epa_workflow_form_alter(&$form, FormStateInterface $form_state, $form_id) {

  if ($form_id == 'node_page_edit_form' || $form_id = 'content_moderation_entity_moderation_form') {

    // The moderation form prints twice on the dashboard. So, lets do this once.
    // This check could be more clear.
    if ($form['#form_id'] != 'views_exposed_form') {
      _epa_workflow_add_compliance_checkboxes($form);
    }
  }

  return $form;
}

/**
 * Helper function to add compliance checkboxes to some forms
 * @param $form
 */
function _epa_workflow_add_compliance_checkboxes(&$form) {

    $link_508 = Link::fromTextAndUrl(
    t('applicable Section 508 standards'),
    Url::fromUri('http://intranet.epa.gov/accessibility/checklist.html')
  );

  $link_508 = $link_508->toString();

  $link_external = Link::fromTextAndUrl(
    t("EPA's External Site Links Procedure"),
    Url::fromUri('https://www.epa.gov/web-policies-and-procedures/procedure-external-site-links')
  );
  $link_external = $link_external->toString();

  // Create a checkbox for 508 compliance agreement
  $form['workflow_508_compliant'] = [
    '#type' => 'checkbox',
    '#title' => t('I certify that all links on this page comply with @external.', [
        '@external' => $link_external,
      ]
    ),
    '#description' => t('I certify that the content on this page is accessible per all @508. ' .
      'This content will be subject to random external site link reviews by the Office of Web Communications, ' .
      'and that non-compliant pages will be unpublished until remediated.', [
    '@508' => $link_508,
    ]),
    '#required' => FALSE,
    '#weight' => -1,
  ];

  // Make the element visible when publish is selected on the latest revision.
  if ($form['#form_id'] == 'content_moderation_entity_moderation_form') {
    $form['workflow_508_compliant']['#states'] = [
      'visible' => [
        ':input[name="new_state"]' => ['value' => 'published'],
      ],
    ];
  }

  // Make the element visible on VBO edits.
  if ($form['#form_id'] == 'views_form_content_page_1') {
    $form['workflow_508_compliant']['#states'] = [
      'visible' => [
        ':input[name="action"]' => ['value' => 'set_to_published'],
      ],
    ];
  }

  $form['workflow_508_compliant']['widget']['#element_validate'] = ['_epa_workflow_form_validation_508'];
}


/**
 * Validation for compliance 508 checkbox.  Must require
 * the checkboxes be ticked when moving content to published.
 */
function _epa_workflow_form_validation_508($element, FormStateInterface $form_state, $form) {

  // Node edit form
  $op = $form_state->getValue('op');

  // Block form on latest revision
  if ($form['#form_id'] == 'content_moderation_entity_moderation_form') {
    $op = $form_state->getValue('new_state');
  }

  // VBO form on content dashboard
  if ($form['#form_id'] == 'views_form_content_page_1') {
    $op = $form_state->getValue('action');
  }

  if ($op == 'Publish' || $op == 'published' || $op == 'set_to_published')  {
    if (empty($form_state->getValue('workflow_508_compliant'))) {
      $form_state->setError($element, t('508 compliance is required to Publish content.'));
    }
  }
}
