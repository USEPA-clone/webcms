<?php

/**
 * @file
 * Contains epa_workflow.module.
 */

use Drupal\content_moderation\Entity\ContentModerationStateInterface;
use Drupal\content_moderation_notifications\ContentModerationNotificationInterface;
use Drupal\Core\Entity\EntityInterface;
use Drupal\Core\Entity\EntityTypeInterface;
use Drupal\Core\Field\BaseFieldDefinition;
use Drupal\Core\Form\FormStateInterface;

/**
 * Implements hook_entity_base_field_info().
 */
function epa_workflow_entity_base_field_info(EntityTypeInterface $entity_type) {
  $fields = [];
  $config_syncing = \Drupal::isConfigSyncing();
  if ($entity_type->id() == 'node' && !$config_syncing) {
    $fields['epa_revision_automated'] = BaseFieldDefinition::create('boolean')
      ->setLabel(t('Moderation automated'))
      ->setDescription(t('When true current moderation state is automated.'))
      ->setRevisionable(TRUE)
      ->setDefaultValue(NULL);
  }
  return $fields;
}

/**
 * Implements hook_ENTITY_TYPE_insert().
 */
function epa_workflow_content_moderation_state_insert(ContentModerationStateInterface $entity) {
  $epa_moderation = \Drupal::service('epa_workflow.moderation_manager');
  if ($epa_moderation->isModeratedEntity($entity)) {
    $epa_moderation->processModeration($entity);
  }
}

/**
 * Implements hook_ENTITY_TYPE_update().
 *
 * @see Drupal\group\Entity\GroupContent::postSave
 * @see https://www.drupal.org/project/group/issues/2872697
 * @see https://www.drupal.org/project/drupal/issues/2803717
 */
function epa_workflow_content_moderation_state_update(ContentModerationStateInterface $entity) {
  $epa_moderation = \Drupal::service('epa_workflow.moderation_manager');
  // Group will trigger an update after insert.
  // Check to see if entity is moderated.
  // Check to see if content revision id has changed.
  // Also, check that the moderation state isn't looping over itself.
  if ($epa_moderation->isModeratedEntity($entity)
      && $entity->content_entity_revision_id->value != $entity->original->content_entity_revision_id->value
      && $entity->getRevisionId() != $entity->getLoadedRevisionId()
  ) {
    $epa_moderation->processModeration($entity);
  }
}

/**
 * Implements hook_form_FORM_ID_alter().
 *
 * @todo This should probably be contributed back.
 */
function epa_workflow_form_content_moderation_notification_form_alter(array &$form, FormStateInterface $form_state) {
  $workflow_id = $form['workflow']['#default_value'];
  $workflow = \Drupal::entityTypeManager()->getStorage('workflow')->load($workflow_id);
  $entity_types = $workflow->getTypePlugin()->getEntityTypes();
  $entity_types[] = 'content_moderation_notifications';
  $form['body']['token_tree_link']['#token_types'] = array_unique(array_merge($form['body']['token_tree_link']['#token_types'], $entity_types));

  $notification = $form_state->getFormObject()->getEntity();
  $workflow_process = $notification->getThirdPartySetting('epa_workflow', 'workflow_process', 'any');
  $workflow_options = [
    'any' => t('Any'),
    'automatic' => t('Automatic'),
    'manual' => t('Manual'),
  ];

  $form['workflow_process'] = [
    '#type' => 'radios',
    '#title' => t('Workflow Process'),
    '#options' => $workflow_options,
    '#description' => t('Notification will react to the selected trigger.'),
    '#default_value' => $workflow_process,
  ];

  $form['#entity_builders']['epa_workflow'] = '_epa_workflow_moderation_form_entity_builder';
}

/**
 * Entity builder for content_moderation_notification_form.
 */
function _epa_workflow_moderation_form_entity_builder($entity_type_id, ContentModerationNotificationInterface $notification, &$form, FormStateInterface &$form_state) {
  $workflow_process = $form_state->getValue('workflow_process', 'any');
  $notification->setThirdPartySetting('epa_workflow', 'workflow_process', $workflow_process);
}

/**
 * Implements hook_mail_alter().
 *
 * Sets header content type to html.
 * Can also achieve by installing mailsystem and add a module specific
 * configuration for content_moderation_notifications.
 *
 * @see https://www.drupal.org/project/content_moderation_notifications/issues/2903550
 */
function epa_workflow_mail_alter(&$message) {
  if ($message['id'] == 'content_moderation_notifications_content_moderation_notification') {
    $message['headers']['Content-Type'] = 'text/html; charset=UTF-8; format=flowed; delsp=yes';

    // Log here to avoid having to create our own mail service
    $logger = \Drupal::logger('epa_workflow');
    $transition = \Drupal::service('content_moderation_notifications.notification_information')->getTransition($message['params']['context']['node']);
    $logger->info('Notification email with subject: %subject was sent to: %to  when the %transition transition was executed on revision %vid', ['%to' => $message['params']['headers']['Bcc'], '%subject' => $message['subject'], '%vid' => $message['params']['context']['node']->getRevisionId(), '%transition' => $transition->label()]);
  }
}

/**
 * Implements hook_content_moderation_notification_mail_data_alter().
 */
function epa_workflow_content_moderation_notification_mail_data_alter(EntityInterface $entity, array &$data) {
  $eic_notifications = [
    'epa_content_has_been_approved',
    'epa_content_needs_review',
    'epa_content_needs_review_manual',
    'epa_content_about_to_expire',
    'epa_content_has_expired',
    'epa_content_will_expire',
  ];
  if (in_array($data['notification']->id, $eic_notifications)) {
    $groups = \Drupal::service('epa_web_areas.web_areas_helper')->getNodeReferencingGroups($entity);
    foreach ($groups as $group) {
      $eic_email = $group->field_editor_in_chief->entity->mail->value;
      if (!in_array($eic_email, $data['to'])) {
        $data['to'][] = $eic_email;
      }

      // Add editors for all notifications except Published needs review.
      if ($data['notification']->id != 'epa_content_needs_review') {
        $members = $group->getMembers('editor');
        foreach ($members as $member) {
          $editor_email = $member->getUser()->getEmail();
          if (!in_array($editor_email, $data['to'])) {
            $data['to'][] = $editor_email;
          }
        }
      }
    }
  }
}

/**
 * Implements hook_field_formatter_info_alter().
 */
function epa_workflow_field_formatter_info_alter(array &$info) {
  if (!empty($info['scheduled_publish_generic_formatter'])) {
    $info['scheduled_publish_generic_formatter']['class'] = 'Drupal\epa_workflow\Plugin\Field\FieldFormatter\EPAScheduledPublishGenericFormatter';
  }
}

/**
 * Implements hook_ENTITY_TYPE_revision_create().
 */
function epa_workflow_node_revision_create(EntityInterface $new_revision, EntityInterface $entity, $keep_untranslatable_fields) {
  // remove any schedule field settings from the previous revision
  $new_revision->set('field_scheduled_transition', NULL);
}

use Symfony\Component\HttpKernel\Exception\AccessDeniedHttpException;
use Symfony\Component\HttpFoundation\BinaryFileResponse;
use Symfony\Component\HttpKernel\Exception\NotFoundHttpException;

function epa_workflow_node_export($node) {
  global $user;

  // Bail early if the node isn't published
  if(!$node->isPublished()) {
      throw new AccessDeniedHttpException();
  }

  $url = url('node/'. $node->getID(), array('absolute' => TRUE, 'base_url' => 'https://localhost:8443'));

  //$this->logger->notice( 'Exporting %:url.', ['%url' => $url]);

  $client = \Drupal::httpClient();
  $method = 'GET';
  $options = [];

  try {
    $response = $client->request($method, $url, $options);
    $code = $response->getStatusCode();
    if ($code == 200) {
      $tempnam = \Drupal\Core\File\FileSystem::tempnam('temporary://', 'epa_workflow_export_');
      $export_uri = $tempnam . '_1';
      $export_dir = \Drupal\Core\File\FileSystem::realpath($export_uri);
      exec("cd " . dirname($export_dir) . " && wget --execute robots=off --restrict-file-names=windows --no-host-directories --timestamping --convert-links --adjust-extension --directory-prefix=" . basename($export_dir) . " --recursive --level=1 --page-requisites -I /sites,/epafiles,/misc $url", $output, $return);

      // Bail out if we had an error during the wget call.
      if ($return != 0) {
        //$this->logger->notice('Error while exporting: %return', array('%return' => $return));

        throw new NotFoundHttpException();;
      }

      $export_uri_filename = $export_uri . '.zip';
      $export_filename = \Drupal\Core\File\FileSystem::realpath($export_uri_filename);
      $zip = new ZipArchive();
      $res = $zip->open($export_filename, ZipArchive::CREATE | ZipArchive::OVERWRITE);
      if ($res === TRUE) {
        $files = new RecursiveIteratorIterator(
          new RecursiveDirectoryIterator($export_dir),
          RecursiveIteratorIterator::LEAVES_ONLY
        );

        foreach ($files as $name => $file) {
          // Skip directories (they would be added automatically)
          if (!$file->isDir()) {
            // Get real and relative path for current file
            $filePath = $file->getRealPath();
            $relativePath = substr($filePath, strlen($export_dir) + 1);

            // Add current file to archive
            $zip->addFile($filePath, $relativePath);
          }
        }

        // Zip archive will be created only after closing object
        $zip->close();

        // Deliver file
        if (file_exists($export_uri_filename)) {
          // Record this download
          $machine_name = _epa_core_get_machine_name_alias($node);
          $timestamp = \Drupal\Core\Datetime\DateFormatter::format(time(), 'custom', 'Y-m-d_H-i');
          $headers = [
            'Content-Type' => mime_header_encode('application/zip'),
            'Cache-Control' => 'private',
            'Content-Disposition' => 'attachment; filename="' . $machine_name . '_' . $timestamp . '.zip"',
          ];

          new BinaryFileResponse(export_uri_filename, 200, $headers);
        }
      }
      else {
        //$this->logger->notice('Error while exporting node: %title - %id', array('%title' => $node->title, '%id' => $node->nid));
      }
    }
    else {
      //$this->logger->notice('Could not export page at %url.  Non-200 response code received: %code', array('%url' => $url, '%code' => $response->code));
    }
    throw new NotFoundHttpException();
  }
  catch (RequestException $e) {
    //$this->logger->notice('Could not export page at %url.' . $e );
  }
}

